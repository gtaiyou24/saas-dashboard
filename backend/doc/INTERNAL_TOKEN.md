# 🦅 内部通信用トークン
内部通信用トークンは、マイクロサービスや分散システム間での安全な通信を確保するために使用される認証手段の一つです。
これにより、個別のサービス間で認証情報をやり取りする際に、エンドユーザーに負担をかけることなく安全性を担保できます。

モジュラモノリス構成の時点では不要ですが、今後マイクロサービス化を見据えている場合は事前に仕組みを用意してもよいでしょう。

## 📝 仕様
### ☝️ API Gateway から1リクエストにつき1トークンが発行される
内部通信トークンは API Gateway から1リクエストにつき1トークン発行されます。
API Gateway 上では HTTP リクエストの認証アクセストークンの検証を行われ、問題のないリクエストのみが API Gateway 裏側のマイクロサービスへ通過します。 
その際に、HTTP ヘッダ上に内部通信用トークンが付加された上でリクエストが送られます。 
またマイクロサービスから別のマイクロサービスへの通信が発生する場合にも、内部通信用トークンはそのまま伝搬されます。

### ✨ 内部通信用トークンは JWT 形式
内部通信用トークンは、JWT(JSON Web Token)です。JWT とは、JSON を署名付きで暗号化した文字列のことです。
JSON には認証ユーザー ID や内部通信用トークン ID, パーミッション情報など各マイクロサービスで利用する情報が含まれています。

![](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F3137271%2F895c3bfd-90cb-c0f5-7642-04066530a24a.jpeg?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=d4d5a97bc77303d24f8d1b79c4185c44)

```python
# pip install pyjwt
import jwt

payload = {
    "iss": "api_gateway",
    "sub": "internal_token",
    # ...
}

internal_token = jwt.encode(payload, "secret", algorithm="HS256")
print(internal_token)
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb21lIjoicGF5bG9hZCJ9.4twFt5NiznN84AWoo1d7KO1T_yoc0Z6XOpOVswacPZg


from Crypto.PublicKey import RSA

# 署名検証用の公開鍵
rsa_public_key_pem = open('path/to/public_key.pem', 'r').read()
rsa_key = RSA.importKey(rsa_public_key_pem)
public_key = rsa_key.exportKey()

# 署名検証
jwt.decode(internal_token, key=public_key, verify=True)
# {'iss': 'api_gateway', ...}
```

### ✅ 各マイクロサービスで内部通信用トークンの署名を検証する
各マイクロサービスでは、事前にインストールされた内部通信用トークンの署名を検証するライブラリを用いて、トークンの検証を行います。
また、ライブラリは署名検証用の公開鍵をキャッシュするため、通信レスでトークン検証できるようにします。

## 💡 内部通信トークンが解決する問題
### 💡 分散トレーシング問題を可能にする
分散トレーシング問題とは、マイクロサービスにおいてサービス間の通信や処理の流れを追跡し、問題の原因を特定することです。
現代のソフトウェアアーキテクチャでは、マイクロサービスやクラウドベースの環境など、複数の異なるサービスが連携して動作するため、問題の特定が複雑になります。
そのため、具体的にマイクロサービスにおいて分散トレーシング問題には以下のようなものがあります。

 - **サービス間の特定依存関係の複雑さ**: 各サービスが他のサービスに依存している場合、どのサービスがボトルネックになっているのかや、どこでエラーが発生したかを特定するのが難しい。
 - **ログの断片化**: 各サービスが独立してログを記録するため、エンドツーエンドのリクエストの全体像を把握するためにログを集約して分析する必要があります。
 - **パフォーマンスのオーバーヘッド**: 分散トレーシングのツールを導入すると、リクエストやレスポンスの追跡のためにシステムに追加の負荷がかかり、パフォーマンスに悪影響を与えることがあります。

内部通信アクセストークンは、ログ出力時に必ず内部通信トークンIDを付与したりすることでログの追跡を可能にし、ボトルネックの特定やログの集約を可能にできます。

### 💡マイクロサービス間の無駄な通信回数を減らせる
内部通信トークンには、ユーザー情報や内部通信トークンID、テナントIDなどそのリクエスト上で変わらない不変的な情報でかつどのマイクロサービスからも参照したい情報があります。
そのため、各マイクロサービスでアクセストークンの検証を行うために認証サーバーにリクエストしたり、ユーザー情報の取得やシステムで必須となる情報をその都度取得する必要がなくなり、結果として無駄な通信回数を減らせます。

## 🔗 Appendix

 - [マイクロサービスでの認証認可 #OAuth - Qiita](https://qiita.com/unhurried/items/998a386ccbc1ad4b8e61)
 - [【書き起こし】メルペイチームが考える「ゼロトラスト」をベースとした認証・認可の在り方と課題 #merpay_techtalk | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20220217-11d92ef626/)
 - [【書き起こし】メルカリグループの認証基盤における理想と現状、今後の取り組み – kokukuma 【Merpay Tech Fest 2022】 | メルカリエンジニアリング](https://engineering.mercari.com/blog/entry/20221018-mtf2022-day2-5/)
